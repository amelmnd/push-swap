
#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H

# include "libft/libft.h"
# include <stdio.h> //a delete
# include <stdlib.h>
# include <unistd.h>

typedef struct s_node
{
	int				value;
	int				index;
	struct s_node	*next;
}					t_node;

// FN DEV DELETE LATER
void				print_pile(t_node *pile);
int					nb_str(char *str, char c);
void				print_pile_index(t_node *pile);

// UTILS
void				ft_exit(int status);
int					ft_int_array_len(int *nb);
void				ft_putstr(char *s);
int					size_pile(t_node *pile);
void				index_more_small(t_node *pile, int *min, int size);

// PARSING
t_node				*check_arg(int argc, char *argv[], t_node *pile);
int					has_valid_arg(char *value);
int					ft_atoi_p(char *str);
t_node				*ft_split_atoi(char *s, char sep, t_node *pile);
void				has_duplicate_pile(t_node *pile);
int					is_sorted(t_node *pile);

// CHAIN LIST
int					is_empty(t_node *pile);
t_node				*ft_push(t_node *pile, int item);
int					ft_pop(t_node *pile);
// void				ft_swap(t_node *pile);

// INSTRUCTIONS
void				ft_push_pile(t_node **pile_cut, t_node **pile_add,
						char *pile_name);
void				ft_swap_pile(t_node *pile, char *pile_name);
void				ft_swap_ss(t_node *pile_a, t_node *pile_b);
void				ft_rotate_pile(t_node *pile, char *pile_name);
void				ft_rotate_rr(t_node *pile_a, t_node *pile_b);
void				ft_reverse_rotate_pile(t_node **pile, char *pile_name);
void				ft_reverse_rotate_rrr(t_node **pile_a, t_node **pile_b);

// EXECUTE INSTRUCTION & SORT
void				execute_instruction(t_node *pile_a, t_node *pile_b);
void				three_sort(t_node *pile_a);
void				four_sort(t_node *pile_a, t_node *pile_b, int size_list);
void				five_sort(t_node *pile_a, t_node *pile_b, int size_list);
void				bubble_sort(int arr[], int n);
void				call_buble_sort(t_node *pile_a, int size_pile_a,
						int *max_value);
void				radix_sort(t_node **pile_a, t_node **pile_b);
#endif
int	pop_first_node(t_node *pile, int pop_value)
{
	t_node	*temp;
	t_node	*previous;

	previous = pile;
	temp = previous->next;
	while (temp != NULL)
	{
		pop_value = temp->value;
		if (temp->next == NULL)
		{
			previous->next = temp->next;
			free(temp);
			return (pop_value);
		}
		previous = temp;
		temp = temp->next;
	}
	return (pop_value);
}

int	ft_pop(t_node *pile)
{
	int	pop_value;

	pop_value = 0;
	if (is_empty(pile))
	{
		free(pile);
		exit(EXIT_SUCCESS);
	}
	if (pile->next == NULL)
	{
		pop_value = pile->value;
		free(pile);
	}
	else
	{
		pop_value = pop_first_node(pile, pop_value);
	}
	return (pop_value);
}

t_node	*ft_push(t_node *pile, int item)
{
	t_node	*new_node;

	new_node = malloc(sizeof(t_node));
	if (!new_node)
		return (NULL);
	new_node->value = item;
	if (is_empty(pile))
		new_node->next = NULL;
	else
		new_node->next = pile;
	return (new_node);
}

void	ft_push_pile(t_node **pile_cut, t_node **pile_add, char *pile_name)
{
	t_node	*node_to_push;

	if (*pile_cut)
	{
		node_to_push = *pile_cut;
		*pile_cut = (*pile_cut)->next;
		node_to_push->next = *pile_add;
		*pile_add = node_to_push;
		ft_putstr(pile_name);
	}
}


#include "push_swap.h"

void	ft_reverse_rotate_pile(t_node **pile, char *pile_name)
{
	t_node	*last;
	t_node	*first;

	if (*pile == NULL || (*pile)->next == NULL)
		return ;
	last = *pile;
	while (last->next->next != NULL)
	{
		last = last->next;
	}
	first = *pile;
	*pile = last->next;
	last->next = NULL;
	(*pile)->next = first;
	if (pile_name)
		ft_putstr(pile_name);
}

void	ft_reverse_rotate_rrr(t_node **pile_a, t_node **pile_b)
{
	ft_reverse_rotate_pile(pile_a, "");
	ft_reverse_rotate_pile(pile_b, "");
	ft_putstr("rrr");
}

void	ft_rotate_pile(t_node *pile, char *pile_name)
{
	t_node	*tmp;
	int		first_value;

	if (pile == NULL || pile->next == NULL)
		return ;
	tmp = pile;
	first_value = pile->value;
	while (tmp->next != NULL)
	{
		tmp->value = tmp->next->value;
		tmp = tmp->next;
	}
	tmp->value = first_value;
	if (pile_name)
		ft_putstr(pile_name);
}

void	ft_rotate_rr(t_node *pile_a, t_node *pile_b)
{
	ft_rotate_pile(pile_a, "");
	ft_rotate_pile(pile_b, "");
	ft_putstr("rr");
}

void	ft_swap_pile(t_node *pile, char *pile_name)
{
	int	tmp;

	if (pile == NULL || pile->next == NULL)
		return ;
	tmp = pile->value;
	pile->value = pile->next->value;
	pile->next->value = tmp;
	if (pile_name)
		ft_putstr(pile_name);
}

void	ft_swap_ss(t_node *pile_a, t_node *pile_b)
{
	ft_swap_pile(pile_a, "");
	ft_swap_pile(pile_b, "");
	ft_putstr("ss");
}

void	has_duplicate_pile(t_node *pile)
{
	t_node	*current_item;
	t_node	*next_item;

	current_item = pile;
	while (current_item != NULL)
	{
		next_item = current_item->next;
		while (next_item != NULL)
		{
			if (next_item->value == current_item->value)
			{
				ft_exit(-1);
			}
			next_item = next_item->next;
		}
		current_item = current_item->next;
	}
}

int	is_sorted(t_node *pile)
{
	t_node	*current;

	current = pile;
	while (current != NULL && current->next != NULL)
	{
		if (current->value > current->next->value)
		{
			return (0);
			// NON TRIER
		}
		current = current->next;
	}
	return (1);
	// TRIER
}

t_node	*check_arg(int argc, char *argv[], t_node *pile_a)
{
	int	has_space;
	int	i;

	if (!argv[1][0])
		ft_exit(0);
	i = argc - 1;
	while (argv[i] && i > 0)
	{
		has_space = has_valid_arg(argv[i]);
		if (!has_space)
		{
			pile_a = ft_push(pile_a, ft_atoi_p(argv[i]));
		}
		else
		{
			pile_a = ft_split_atoi(argv[i], ' ', pile_a);
		}
		i--;
	}
	has_duplicate_pile(pile_a);
	if (is_sorted(pile_a))
		ft_exit(0);
	return (pile_a);
}

int	nb_str(char *str, char c)
{
	int	i;
	int	nb_word;

	i = 0;
	nb_word = 0;
	while (str[i] != '\0')
	{
		if (str[i] != c && (str[i + 1] == c || str[i + 1] == '\0'))
		{
			nb_word++;
		}
		i++;
	}
	return (nb_word);
}

int	ft_atoi_p(char *str)
{
	int			i;
	int			neg;
	long long	res;

	i = 0;
	neg = 0;
	res = 0;
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == 32)
		i++;
	if (str[i] == '-')
		neg = 1;
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i] >= '0' && str[i] <= '9')
	{
		res = res + (str[i] - 48);
		i++;
		if (str[i] != '\0' && (str[i] >= '0' && str[i] <= '9'))
			res = res * 10;
		if ((res > 2147483648 && neg == 1) || (res > 2147483647 && neg == 0))
			ft_exit(-1);
	}
	if (neg == 1)
		return (res * -1);
	return (res);
}

void	create_int(int *tab, int j, char *str, int startword, int len_world)
{
	char	*tmp;

	tmp = ft_substr(str, startword, len_world);
	if (!tmp)
		exit(-1);
	tab[j] = ft_atoi_p(tmp);
	free(tmp);
}

void	create_array(char *str, char sep, int tab_size, int *tab)
{
	int	i;
	int	startword;
	int	len_world;
	int	j;

	j = 0;
	i = 0;
	while (str[i] != '\0')
	{
		len_world = 0;
		if (str[i] == sep)
			i++;
		startword = i;
		if (str[i] != sep)
		{
			while (str[i] != sep && str[i] != '\0')
			{
				len_world++;
				if ((str[i + 1] == sep || str[i + 1] == '\0') && j < tab_size)
					create_int(tab, j++, str, startword, len_world);
				i++;
			}
		}
	}
}

t_node	*create_pile(t_node *pile, int *tab, int tab_size)
{
	while (tab_size--)
	{
		pile = ft_push(pile, tab[tab_size]);
	}
	return (pile);
}

t_node	*ft_split_atoi(char *s, char sep, t_node *pile)
{
	int		tab_size;
	char	*str;
	int		*tab;

	str = (char *)s;
	if (!str)
		exit(-1);
	tab_size = nb_str(str, sep);
	if (tab_size == 0)
		exit(-1);
	tab = (int *)malloc(sizeof(int) * tab_size + 1);
	if (!tab)
		return (NULL);
	create_array(str, sep, tab_size, tab);
	pile = create_pile(pile, tab, tab_size);
	free(tab);
	return (pile);
}

int	has_valid_arg(char *value)
{
	int		i;
	char	space;

	i = 0;
	space = 0;
	while (value[i])
	{
		if (!ft_isdigit(value[i]) && value[i] != '-' && value[i] != ' ')
		{
			ft_exit(-1);
		}
		else if (value[i] == ' ')
		{
			space = 1;
		}
		i++;
	}
	return (space);
}

void	bubble_sort(int arr[], int n)
{
	int	temp;
	int	i;
	int	j;

	i = 0;
	while (i < n - 1)
	{
		j = 0;
		while (j < n - i - 1)
		{
			if (arr[j] > arr[j + 1])
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
			j++;
		}
		i++;
	}
}

void	index_pile(t_node *pile_a, int *array_from_stack, int size_pile_a)
{
	int		i;
	t_node	*tmp;
	int		index;

	i = 0;
	index = 0;
	while (i < size_pile_a)
	{
		tmp = pile_a;
		while (tmp)
		{
			if (tmp->value == array_from_stack[i])
			{
				tmp->index = index;
				index++;
				break ;
			}
			tmp = tmp->next;
		}
		i++;
	}
}

void	call_buble_sort(t_node *pile_a, int size_pile_a, int *max_value)
{
	int		*array_from_stack;
	int		i;
	t_node	*tmp;

	tmp = pile_a;
	i = 0;
	array_from_stack = malloc(sizeof(int) * size_pile_a);
	while (tmp != NULL)
	{
		array_from_stack[i] = tmp->value;
		tmp = tmp->next;
		i++;
	}

	bubble_sort(array_from_stack, size_pile_a);
	*max_value = array_from_stack[size_pile_a - 1];
	index_pile(pile_a, array_from_stack, size_pile_a);
	free(array_from_stack);
}

void	five_sort(t_node *pile_a, t_node *pile_b, int size_list)
{
	int	min;

	min = 1;
	index_more_small(pile_a, &min, size_list);
	if (min == 1)
	{
		ft_push_pile(&pile_a, &pile_b, "pb");
		four_sort(pile_a, pile_b, size_list - 1);
		ft_push_pile(&pile_b, &pile_a, "pa");
	}
	else if (min == 2)
		ft_swap_pile(pile_a, "sa");
	else if (min == 3)
	{
		ft_reverse_rotate_pile(&pile_a, "rra");
		ft_reverse_rotate_pile(&pile_a, "rra");
		ft_reverse_rotate_pile(&pile_a, "rra");
	}
	else if (min == 4)
	{
		ft_reverse_rotate_pile(&pile_a, "rra");
		ft_reverse_rotate_pile(&pile_a, "rra");
	}
	else if (min == 5)
		ft_reverse_rotate_pile(&pile_a, "rra");
	if (is_sorted(pile_a) == 0)
	{
		ft_push_pile(&pile_a, &pile_b, "pb");
		four_sort(pile_a, pile_b, size_list - 1);
		ft_push_pile(&pile_b, &pile_a, "pa");
	}
}

void	four_sort(t_node *pile_a, t_node *pile_b, int size_list)
{
	int	min;

	min = 1;
	index_more_small(pile_a, &min, size_list);
	if (min == 1)
	{
		ft_push_pile(&pile_a, &pile_b, "pb");
		three_sort(pile_a);
		ft_push_pile(&pile_b, &pile_a, "pa");
	}
	else if (min == 2)
		ft_swap_pile(pile_a, "sa");
	else if (min == 3)
	{
		ft_reverse_rotate_pile(&pile_a, "rra");
		ft_reverse_rotate_pile(&pile_a, "rra");
	}
	else if (min == 4)
		ft_reverse_rotate_pile(&pile_a, "rra");
	if (is_sorted(pile_a) == 0)
	{
		ft_push_pile(&pile_a, &pile_b, "pb");
		three_sort(pile_a);
		ft_push_pile(&pile_b, &pile_a, "pa");
	}
}


void	three_sort(t_node *pile_a)
{
	while (!is_sorted(pile_a))
	{
		if ((pile_a->value > pile_a->next->value)
			&& (pile_a->next->value > pile_a->next->next->value))
		{
			ft_rotate_pile(pile_a, "ra");
			ft_swap_pile(pile_a, "sa");
		}
		else
		{
			if (is_sorted(pile_a->next))
				ft_rotate_pile(pile_a, "ra");
			else if (pile_a->value > pile_a->next->value)
				ft_swap_pile(pile_a, "sa");
			else if (pile_a->value > pile_a->next->next->value)
				ft_reverse_rotate_pile(&pile_a, "rra");
			else if (pile_a->next->value > pile_a->next->next->value)
				ft_rotate_pile(pile_a, "ra");
		}
	}
}
int	is_empty(t_node *pile)
{
	if (pile == NULL)
		return (1);
	return (0);
}

void	ft_exit(int status)
{
	if (status == 0)
		exit(EXIT_SUCCESS);
	else if (status == -1)
	{
		ft_putstr_fd("Error\n", 2);
		exit(EXIT_FAILURE);
	}
}

void	ft_putstr(char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		write(1, &s[i], 1);
		i++;
	}
	write(1, "\n", 1);
}

int	size_pile(t_node *pile)
{
	int	size;

	size = 0;
	if (pile)
	{
		while (pile != NULL)
		{
			pile = pile->next;
			size++;
		}
		return (size);
	}
	return (0);
}

//TODO cette fonction gerer 2 leaks
/*
2 (32 bytes) ROOT LEAK: 0x60000154c060 [16]  length: 1  "U"
1 (16 bytes) 0x60000154c050 [16]
*/
void	index_more_small(t_node *pile, int *min, int size)
{
	t_node	*tmp1;
	t_node	*tmp2;
	int		i;
	int		more_small;

	tmp1 = pile;
	i = 1;
	more_small = tmp1->value;
	while (i <= size)
	{
		tmp2 = pile;
		while (tmp2 != NULL)
		{
			if (tmp2->value < more_small)
			{
				*min = i;
				more_small = tmp1->value;
			}
			tmp2 = tmp2->next;
		}
		tmp1 = tmp1->next;
		i++;
	}
}
void	print_pile(t_node *pile)
{
	if (pile == NULL)
	{
		printf("pile is empty\n");
		return ;
	}
	else
	{
		while (pile != NULL)
		{
			printf("-> [%d]\n", pile->value);
			pile = pile->next;
		}
	}
}

void	print_pile_index(t_node *pile)
{
	if (pile == NULL)
	{
		printf("pile is empty\n");
		return ;
	}
	else
	{
		while (pile != NULL)
		{
			printf("v (%d): -> i : [%d]\n", pile->value, pile->index);
			pile = pile->next;
		}
	}
}
void	execute_instruction(t_node *pile_a, t_node *pile_b)
{
	int	size_pile_a;
	int	size_pile_b;
	int	max_value;

	size_pile_a = size_pile(pile_a);
	size_pile_b = size_pile(pile_b);
	if (size_pile_a == 2 && size_pile_b == 0)
		ft_swap_pile(pile_a, "sa");
	else if (size_pile_a == 3)
		three_sort(pile_a);
	else if (size_pile_a == 4)
	{
		four_sort(pile_a, pile_b, size_pile_a);
	}
	else if (size_pile_a == 5)
	{
		five_sort(pile_a, pile_b, size_pile_a);
	}
	else if (size_pile_a > 5)
	{
		printf("---- more 5 ----\n");
		max_value = 0;
		call_buble_sort(pile_a, size_pile_a, &max_value);
		radix_sort(&pile_a, &pile_b);
		// À ce stade, la pile a doit être triée
		// if (!is_empty(pile_a))
		// {
		// 	print_pile(pile_a);
		// }
	}
	else
		ft_exit(-1);
}

int	main(int argc, char *argv[])
{
	t_node	*pile_a;
	t_node	*pile_b;

	pile_a = NULL;
	pile_b = NULL;
	if (argc < 2)
		ft_exit(0);
	else
	{
		pile_a = check_arg(argc, argv, pile_a);
	}
	if (pile_a == NULL)
		ft_exit(-1);
	execute_instruction(pile_a, pile_b);
	system("leaks push_swap");
	return (0);
}
